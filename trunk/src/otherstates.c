#pragma config(Sensor, S2,     lightSensor,         sensorLightInactive)
#pragma config(Sensor, S3,     soundSensor,         sensorSoundDB)
#pragma config(Sensor, S4,     touchSensor,         sensorTouch)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//globals
#define soundBuffer   13
#define foundSoundLvl 90
#define foundSoundLv2 60
#define turnRadius    800
#define turnIncrement 90
#define turnBack      0
#define turnSpeed     20
#define gototurnSpeed 40
#define goSpeed       30

#define TRAP_LIGHT_THRESHOLD 20
#define DISTRESS_TIMEOUT 300000

//initiate variables
short oldsoundMax;
short state;

//states
#define TURNFORSOUND   1
#define GOTOSOUND      2
#define FOUNDPRINCESS  3
#define IMTHEPRINCESS  4

//Sound-seeking method
//1 to find loudest sound
//2 to find quitest sound
//3 to use vector addition population encoder
#define USE_LOUDEST    1
#define USE_SOFTEST    2
#define USE_VECTORADD  3


void TurnRight(short degree) //Function to rotate the robot "degree" degrees to the right
{
  nSyncedTurnRatio = -100; //Makes the wheels turn in opposite directions
  nMotorEncoder[motorA] = 0; // Initialize wheel counter
  while(nMotorEncoder[motorA] < degree)
  {
    motor[motorA] = 25; //Establish turn power
  }
  motor[motorA] = 0;
  nSyncedTurnRatio = 100;
  wait1Msec(100); //Pause to reduce jerking between operations
}

void GoReverse(short distance)  //input is the distance we wish to go in inches
{
  nMotorEncoder[motorA] = 0;
  nSyncedTurnRatio = 100;

  //1 rotation is approximately 7.25 inches
  while(nMotorEncoder[motorA] > -1*distance*(360/7.25))  //Calculates distance in inches
  {                                                      //as a function of wheel rotations
    motor[motorA] = -30;  //Reverse Motor speed
  }
  motor[motorA] = 0;
  wait1Msec(100);
}

void DisplayData(short data, bool firstDisplay)
{
  if(firstDisplay)
  {
    nxtDisplayCenteredTextLine(0, "Sound Reading");
    nxtDisplayCenteredBigTextLine(1, "%d", data);
  }
  else
  {
    nxtDisplayCenteredTextLine(4, "Max Sound Reading");
    nxtDisplayCenteredBigTextLine(5, "%d", data);
  }
}

task ProduceDistressSignal() {
  while (true){
    nVolume = 4;
    PlayTone(1184,100);
    wait1Msec(100);
  }
}

bool inTrap() {
  if(SensorValue[lightSensor] <= TRAP_LIGHT_THRESHOLD) {
    return true;
  }
  return false;
}

void moveAwayFromTrap() {
  // Try to get away from the trap
	// by travelling straight for 5 secs
  wait10Msec(200);
  motor(motorA) = goSpeed;
	wait1Msec(5000);
	motor(motorA) = 0;
}

void imThePrincess() {
  motor(motorA) = 0;
  motor(motorB) = 0;
  wait10Msec(200);
  StartTask(ProduceDistressSignal);
	wait1Msec(DISTRESS_TIMEOUT);
	StopTask(DISTRESS_TIMEOUT);
	moveAwayFromTrap();
	state = GOTOSOUND;
}

void foundPrincess() {
   motor(motorA) = 0;
   motor(motorB) = 0;
   wait10Msec(200);
   while(SensorValue[soundSensor] > foundSoundLv2) {
   }
   moveAwayFromTrap();
   state = GOTOSOUND;
}

task main() {
  motor(motorB) = 0;                                                      //Estop
  nSyncedMotors         = synchAB;
  nSyncedTurnRatio      = 100;
  state = GOTOSOUND;
  while(1) {
    switch (state){

      case GOTOSOUND:                                                           //GOTOSOUND state
        motor(motorA) = goSpeed;
        wait10Msec(10);                                                         //Get going before checking sound
        oldsoundMax = SensorValue[soundSensor];                                 //Set old sound max == current sensor lvl

        while (state==GOTOSOUND) {                                               //go loop - go forward while current sound > oldsound - soundbuffer
          motor(motorA) = goSpeed;
          DisplayData(SensorValue[soundSensor],true);
          if (SensorValue[soundSensor] > oldsoundMax){
            oldsoundMax = SensorValue(soundSensor);
          }
          DisplayData(oldsoundMax,false);
          if (SensorValue[touchSensor]==1){
            motor(motorA) = 0;
            GoReverse(4);
            TurnRight(270);
            motor(motorA) = goSpeed;
            wait10Msec(200);
          }
          if((SensorValue[soundSensor] > foundSoundLvl) || (inTrap() && SensorValue[soundSensor] >= foundSoundLv2)){
            state = FOUNDPRINCESS;
            break;
          }
          if(inTrap() && SensorValue[soundSensor] < foundSoundLv2) {
            state = IMTHEPRINCESS;
            break;
          }
          if(SensorValue[soundSensor] < oldsoundMax - soundBuffer){
            state = TURNFORSOUND;
            break;
          }
        }
        break;

      case IMTHEPRINCESS:
        imThePrincess();
        break;

      case FOUNDPRINCESS:
        foundPrincess();
        break;

    }
  }
}
