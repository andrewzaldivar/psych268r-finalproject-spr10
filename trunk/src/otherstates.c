#pragma config(Sensor, S2,     lightSensor,         sensorLightInactive)
#pragma config(Sensor, S1,     soundSensor,         sensorSoundDB)
#pragma config(Sensor, S4,     touchSensor,         sensorTouch)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//globals
#define soundBuffer   13
#define foundSoundLvl 90
#define foundSoundLv2 90
#define turnRadius    800
#define turnIncrement 90
#define turnBack      0
#define turnSpeed     20
#define gototurnSpeed 40
#define goSpeed       30

#define TRAP_LIGHT_THRESHOLD 20
#define DISTRESS_TIMEOUT 3000

//initiate variables
short oldsoundMax;
short state = 2;

//states
#define TURNFORSOUND   1
#define GOTOSOUND      2
#define FOUNDPRINCESS  3
#define IMTHEPRINCESS  4

//Sound-seeking method
//1 to find loudest sound
//2 to find quitest sound
//3 to use vector addition population encoder
#define USE_LOUDEST    1
#define USE_SOFTEST    2
#define USE_VECTORADD  3

void TurnRight(short degree) //Function to rotate the robot "degree" degrees to the right
{
  nSyncedTurnRatio = -100; //Makes the wheels turn in opposite directions
  nMotorEncoder[motorA] = 0; // Initialize wheel counter
  while(nMotorEncoder[motorA] < degree)
  {
    motor[motorA] = 25; //Establish turn power
  }
  motor[motorA] = 0;
  nSyncedTurnRatio = 100;
  wait1Msec(100); //Pause to reduce jerking between operations
}

void GoReverse(short distance)  //input is the distance we wish to go in inches
{
  nMotorEncoder[motorA] = 0;
  nSyncedTurnRatio = 100;

  //1 rotation is approximately 7.25 inches
  while(nMotorEncoder[motorA] > -1*distance*(360/7.25))  //Calculates distance in inches
  {                                                      //as a function of wheel rotations
    motor[motorA] = -30;  //Reverse Motor speed
  }
  motor[motorA] = 0;
  wait1Msec(100);
}

void DisplayData(short data, bool firstDisplay)
{
  if(firstDisplay)
  {
    nxtDisplayCenteredTextLine(0, "Behavior State");
    nxtDisplayCenteredBigTextLine(1, "%d", data);
  }
  else
  {
    nxtDisplayCenteredTextLine(4, "Light Value");
    nxtDisplayCenteredBigTextLine(5, "%d", data);
  }
}

void produceDistressSignal() {

  nVolume = 4;
  // note: intrinsic void PlayTone(const int frequency,  const int durationIn10MsecTicks)
  PlayTone(1184,(DISTRESS_TIMEOUT));
  wait10Msec(DISTRESS_TIMEOUT);
}

bool inTrap() {
  if(SensorValue[lightSensor] <= TRAP_LIGHT_THRESHOLD) {
    return true;
  }
  else {
    return false;
  }
}

void moveAwayFromTrap() {
  // Try to get away from the trap
  // by travelling straight for 5 secs
  wait10Msec(200);
  motor(motorA) = goSpeed;
  wait1Msec(5000);
  motor(motorA) = 0;
  state = GOTOSOUND;
}

void imThePrincess() {
  motor(motorA) = 0;
  motor(motorB) = 0;
  wait10Msec(200);
  produceDistressSignal();
  moveAwayFromTrap();
  state = GOTOSOUND;
}

void foundPrincess() {
   motor(motorA) = 0;
   motor(motorB) = 0;
   wait10Msec(200);
   while(SensorValue[soundSensor] > foundSoundLv2) {
   }
   moveAwayFromTrap();
   state = GOTOSOUND;
}

// Check to see if the behavior state should change
// returns behavior state
short checkBehaviorState(short oldsoundMax) {

  if (inTrap() && SensorValue[soundSensor] < foundSoundLv2)
  {
    return IMTHEPRINCESS;
  }
  else if( (SensorValue[soundSensor] > foundSoundLvl) || (inTrap() && SensorValue[soundSensor] >= foundSoundLv2) )
  {
  return FOUNDPRINCESS;
  }
  else if(SensorValue[soundSensor] < oldsoundMax - soundBuffer)
  {
    // insert turn function here.
    return GOTOSOUND;
  }
  else
  {
    return GOTOSOUND;
  }
}


task main() {
  DisplayData(state,true);
  wait10Msec(1);
  wait10Msec(20);
  nSyncedMotors         = synchAB;
  nSyncedTurnRatio      = 100;
  state = GOTOSOUND;
  DisplayData(state,true);

  while(1) {

    switch (state) {
      case GOTOSOUND:                                             //GOTOSOUND state
        //motor(motorA) = goSpeed;
        wait10Msec(10);                                          //Get going before checking sound
        oldsoundMax = SensorValue[soundSensor];                  //Set old sound max == current sensor lvl

        while (state == GOTOSOUND) {                               //go loop - go forward while current sound > oldsound - soundbuffer
          motor(motorA) = goSpeed;
          //DisplayData(SensorValue[soundSensor],true);
          if (SensorValue[soundSensor] > oldsoundMax) {
            oldsoundMax = SensorValue(soundSensor);
          }

          //DisplayData(oldsoundMax,false);

          // Wall behavior.
          if (SensorValue[touchSensor]==1){
            motor(motorA) = 0;
            GoReverse(4);
            TurnRight(270);
            motor(motorA) = goSpeed;
            wait10Msec(200);
          }

          state = checkBehaviorState(oldsoundMax);
          DisplayData(state,true);
          //DisplayData(SensorValue[lightSensor],false);
        } // end GOTOSOUND while loop

        break;
      case IMTHEPRINCESS:
        imThePrincess();
        break;
      case FOUNDPRINCESS:
        //foundPrincess();
        DisplayData(state,true);
        break;
      case TURNFORSOUND:
        break;
    }
  }
}
