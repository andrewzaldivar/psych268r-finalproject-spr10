#pragma config(Sensor, S1,     soundSensor,         sensorSoundDB)
#pragma config(Sensor, S2,     touchSensor,         sensorTouch)
#pragma config(Sensor, S3,     sonar,               sensorSONAR)
#pragma config(Sensor, S4,     lightSensor,         sensorLightActive)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//globals
#define soundBuffer   13
#define foundSoundLvl 90
#define foundSoundLv2 90
#define turnRadius    800
#define turnIncrement 90
#define turnBack      0
#define turnSpeed     20
#define gototurnSpeed 40
#define goSpeed       30

#define TRAP_LIGHT_THRESHOLD 41

//SONAR
#define sonarTurnSpeed 20                     // Speed at which princess scans surrounds
#define sonarCloseEnoughDist_cm 40            // Dist(cm) radius away from princess to consider other robots "close"
#define sonarSufficientlySurroundedRatio 0.25 // Ratio of close:notClose sonar readings that trigger pricess-is-"rescued".

//initiate variables
short oldsoundMax;
short peakMotorEncoder;
short state;
bool light = true;
int rescueBotCount = 0;

//Sonar init variables
int num_total_sonar_samples = 0;
int num_close_enough_sonar_samples = 0;
float sonar_surrounded_ratio = 0.0;
int sonar_start_motor_enc = 0;
bool isSonarSurrounded = false;
float TURN=(360.00/7.00)*3.14*(15.00/14.00); // 1/4 turn rotation encoder clicks, assuming standard chassis.
int sonarClicksFullTurn = 4 * (int) TURN; // a full turn used for sonar-based scan of surroundings.

//Cluster-detection (rescue detection) method/strategy
#define USE_SONAR 1  // turns on the use of sonar-based detection in conjunction with the pulse-based.
//END SONAR

//states
#define TURNFORSOUND   1
#define GOTOSOUND      2
#define FOUNDPRINCESS  3
#define IMTHEPRINCESS  4

#define BOT_COUNT 5 //Number of rescue bots to assemble before princess is rescued.
#define RESCUEBOT_SOUND_THRESHOLD 50
#define PRINCESS_SILENCE_THRESHOLD 20
#define BEEP_DETECTION_DIFFERENCE 30
#define PRINCESS_FOUND_THRESHOLD 90

//Sound-seeking method
//1 to find loudest sound
//2 to find quitest sound
//3 to use vector addition population encoder
#define USE_LOUDEST    1
#define USE_SOFTEST    2
#define USE_VECTORADD  3

void DisplayData(short data, bool firstDisplay)
{
	if(firstDisplay)
	{
		nxtDisplayCenteredTextLine(0, "Behavior State");
		nxtDisplayCenteredBigTextLine(1, "%d", data);
	}
	else
	{
		nxtDisplayCenteredTextLine(4, "Null Data (Ignore)");
		nxtDisplayCenteredBigTextLine(5, "%d", data);
	}
}

bool inTrap() {
	DisplayData(SensorValue[lightSensor],false);
	if (light) {
		if(SensorValue[lightSensor] <= TRAP_LIGHT_THRESHOLD) {
			return true;
		}
		else {
			return false;
		}
	}
	else {
		return false;
	}
}

// Check to see if the behavior state should change
// returns behavior state
short checkBehaviorState(short oldsoundMax) {

	if (inTrap() && SensorValue[soundSensor] < foundSoundLv2)
	{
		return IMTHEPRINCESS;
	}
	else if( (SensorValue[soundSensor] > foundSoundLvl) || (inTrap() && SensorValue[soundSensor] >= foundSoundLv2) )
	{
		return FOUNDPRINCESS;
	}
	else if(SensorValue[soundSensor] < oldsoundMax - soundBuffer)
	{
		return TURNFORSOUND;
	}
	else
	{
		return GOTOSOUND;
	}
}

void VectorAddition(short &oldDegrees, short &oldMagnitude,short newDegrees, short newMagnitude)
{
	short xDecomp = (oldMagnitude * cosDegrees(oldDegrees)) + (newMagnitude * cosDegrees(newDegrees));
	short yDecomp = (oldMagnitude * sinDegrees(oldDegrees)) + (newMagnitude * sinDegrees(newDegrees));
	oldMagnitude = (xDecomp^2 + yDecomp^2)^.5;
	oldDegrees = radiansToDegrees(acos(xDecomp/oldMagnitude));
	if (xDecomp < 0)
	{
		if (yDecomp < 0) {oldDegrees = oldDegrees + 180;}
		else {oldDegrees = oldDegrees + 90;}
	}
	else { if (yDecomp < 0) {oldDegrees = oldDegrees + 270;} }
	//DisplayData(oldDegrees,false);
}

void TurnRight(short degree) //Function to rotate the robot "degree" degrees to the right
{
	nSyncedTurnRatio = -100; //Makes the wheels turn in opposite directions
	nMotorEncoder[motorA] = 0; // Initialize wheel counter
	while(nMotorEncoder[motorA] < degree)
	{
		motor[motorA] = 25; //Establish turn power
	}
	motor[motorA] = 0;
	nSyncedTurnRatio = 100;
	wait1Msec(100); //Pause to reduce jerking between operations
}

void GoReverse(short distance)  //input is the distance we wish to go in inches
{
	nMotorEncoder[motorA] = 0;
	nSyncedTurnRatio = 100;

	//1 rotation is approximately 7.25 inches
	while(nMotorEncoder[motorA] > -1*distance*(360/7.25))  //Calculates distance in inches
	{                                                      //as a function of wheel rotations
		motor[motorA] = -30;  //Reverse Motor speed
	}
	motor[motorA] = 0;
	wait1Msec(100);
}

void moveAwayFromTrap() {
	// Try to get away from the trap
	// by travelling in reverse for 5 secs
	wait10Msec(200);
	motor(motorA) = -1*goSpeed;
	wait1Msec(5000);
	motor(motorA) = 0;
	TurnRight(180);
	TurnRight(180);
	state = GOTOSOUND;
}

int getMaxSoundForInterval (int interval)
{
	int soundValue = 0;
	int checkValue = 0;
	ClearTimer(T1);
	while (time1[T1] < 500)
	{
		checkValue = SensorValue[soundSensor];
		if (soundValue < checkValue && !bSoundActive)
		{
			soundValue = checkValue;
		}
	}
	return soundValue;
}

int fBeepDetection () //Check and return if the detected sound is in a beep pattern.
{
	int beepDetection = 0;
	ClearTimer (T2);
	wait1Msec (100);
	int initialSound = SensorValue[soundSensor];
	while (time1[T2] < 1000)
	{
		wait1Msec (50);
		int diff = abs (SensorValue[soundSensor] - initialSound);
		if (diff > BEEP_DETECTION_DIFFERENCE)
		{
			beepDetection = 1;
			break;
		}
	}
	return beepDetection;
}

task playRescueTone () // Rescue bots play a tone for 500 msec when the princess is in silent mode.
{
	wait1Msec(100);
	while (1)
	{
		srand(random(13456));
		wait1Msec(random(500));
		//To randomly choose an arbitrary wait time to make the rescue calls discrete and not synchronized in case there are more than one rescue bot in the arena.
		if (SensorValue[soundSensor] < PRINCESS_SILENCE_THRESHOLD && !bSoundActive)
		{
			nVolume = 4;
			PlayTone(1184, 50);
			wait1Msec(510);
			break;
		}
	}
}

//SONAR FUNCTIONS

void TurnRightIndefinite(short turn_speed) { //Function to rotate the robot to the right. Returns immediately, robot still turns.

	nSyncedTurnRatio = -100; //Makes the wheels turn in opposite directions

	motor[motorA] = turn_speed; //Establish turn power

}

void InitSonarDetection() { // Resets sonar-based global variables.

	// Reset the counts of samples
	num_total_sonar_samples = 0;
	num_close_enough_sonar_samples = 0;

	// Reset the (local) motor encoding used here so the robot starts spinning
	// around another revolution.
	sonar_start_motor_enc = nMotorEncoder[motorA]; // Assuming motorA rotates positively while turning

	// Reset the proportion of samples that this robot
	// thinks it is "surrounded" by close-by objects.
	sonar_surrounded_ratio = 0.0;

	// Reset so this thinks it is not surrounded.
	isSonarSurrounded = false;
}

void ContinueSonarDetection() { //Perform a sample-check using sonar and set robot turning.
	// Increment our sample count per 360-degree turn.
	// (Make sure to do this before division, else div-by-0.)
	num_total_sonar_samples++;

	// If the sample was close enough, increment the close
	// enough count.

	if ( SensorValue(sonar) < sonarCloseEnoughDist_cm ) {
		num_close_enough_sonar_samples++;
	}

	// Calculate the current surrounded ratio
	// Commented out since we are not showing this on display.  Uncomment if
	// you want to use this to show what the robot sees, "as it sees it".
	// Calculation is in the end-of-turn if-statement below because that
	// is the only time we need to check this ratio.
	//sonar_surrounded_ratio = (float)num_close_enough_sonar_samples / (float)num_total_sonar_samples;

	// keep turning
	TurnRightIndefinite( sonarTurnSpeed );

	// Only do some other checks if f a full circle has been turned
	if ( (nMotorEncoder[motorB] - sonar_start_motor_enc) < sonarClicksFullTurn ) {

		// We turned a full circle around.
		// Determine how surrounded this robot thinks it is in this cirled turn.
		sonar_surrounded_ratio = (float)num_close_enough_sonar_samples / (float)num_total_sonar_samples;

		// Only on full turns do we check if the
		// robot is sufficiently surrounded
		if ( sonar_surrounded_ratio > (float) sonarSufficientlySurroundedRatio ) {
			isSonarSurrounded = true;
		}
		else {

			// The robot has turned a full circle and not enough
			// surrounding stuff was found.
			// Therefore, we should reset all the sonar-based
			// detection variables so that it can start a new
			// circle afresh.
			InitSonarDetection();

		}
	}

}

task sonarDetection ()
{
	InitSonarDetection();
	while (1)
	{
		if (!isSonarSurrounded)
		{
			ContinueSonarDetection();
		}
	}
}

// END SONAR FUNCTIONS

void imThePrincess() {
	motor(motorA) = 0;
	motor(motorB) = 0;
	wait10Msec(200);

	if (USE_SONAR == 1)
	{  // SONAR-based in parallel with pulse-based
		StartTask(sonarDetection);
	}
	//Do Princess like stuff
	while (1)
	{
		DisplayData(state, true);
		DisplayData(rescueBotCount, false);

		// If the robot is not sufficiently surrounded (rescued) by other robots,
		if (rescueBotCount < BOT_COUNT)
		{
			// Play-mode : short pulse for 500 msec
			nVolume = 4;
			PlayTone(1184, 85); ///Async?!
			wait1Msec (850);

			// Silent-mode : listen to sound for 500 msec
			int rescueSoundValue = getMaxSoundForInterval(500);
			if (rescueSoundValue > RESCUEBOT_SOUND_THRESHOLD) //if there is a rescue-bot around making a noise
			{
				rescueBotCount++; //Increment rescue-bot count.
				DisplayData(rescueBotCount, false);
			}
			wait1Msec (100);
		}

		// Else, the robot is fully surrounded/rescued,
		if (rescueBotCount >= BOT_COUNT && isSonarSurrounded)
		{
			wait1Msec (5100); //Once rescued go silent to kick the rescue bots into disperse mode.
			rescueBotCount = 0; //Reset rescue bot count
			InitSonarDetection();
			StopTask(sonarDetection);	//Reset sonar-based detection variables.
			moveAwayFromTrap();
			state = GOTOSOUND;
			break;
		}
	}
}

void foundPrincess() {
	motor(motorA) = 0;
	motor(motorB) = 0;
	wait10Msec(200);
	StartTask (playRescueTone); //Wait for Princess to shut up and play a tone once to inform her rescue status
	while(1)
	{
		int beepValue = fBeepDetection ();
		if (beepValue == 1) //Check for Beep vs Continuous noise made by the princess. Check 3 times.
		{
			beepValue = fBeepDetection ();
			if (beepValue == 1)
			{
				beepValue = fBeepDetection ();
				if (beepValue == 1)
				{
					DisplayData(state, true);
					DisplayData(1, false);
					motor(motorA) = 0;
				}
			}
		}
		else //When a continuous noise for 3 sec is made by the princess. Check 3 times for continuous tone to make sure the mode is changed to continuous.
		{
			beepValue = fBeepDetection ();
			if (beepValue == 0)
			{
				beepValue = fBeepDetection ();
				if (beepValue == 0)
				{
					DisplayData(state, true);
					DisplayData(0, false);
					moveAwayFromTrap();
					state = GOTOSOUND;
					break;
				}
			}
		}
	}
}

void soundSeeking() {

	short TURNFORSOUND_METHOD = USE_LOUDEST;
	//Sound-seeking method
	//USE_LOUDEST: go towards the loudest sound
	//USE_SOFTEST: go away from the quitest sound
	//USE_VECTORADD: use vector addition, averaging all readings

	//	AddToDatalog(101);

	motor[motorA] = 0;
  	nSyncedMotors = synchNone;                                              //Will occasionally throw "cannot update slave sync" in nMotorEncoder otherwise
	nMotorEncoder[motorA] = 0;                                              //reset nMotorEncoder motorA
	nMotorEncoder[motorB] = 0;                                              //reset nMotorEncoder motorB - redundant
	nSyncedMotors         = synchAB;                                        //Sync Motors for (CW/CCW?)turn - A master, B slave
	nSyncedTurnRatio      = -100;                                           //Sync for in place turning
	oldsoundMax           = 0;                                              //reset oldsoundMax
	if(TURNFORSOUND_METHOD == USE_SOFTEST)
	{
		oldsoundMax = 100;
	}

	peakMotorEncoder      = 0;                                      //reset turn1peakdBmotorValue

	wait10Msec(50);
	short magnitude = 0;
	short motorEncoderTarget = 0;
	int soundReading = 0;


	//Loop through 1 circle and sample sound levels
	while(nMotorEncoder[motorA] <= turnRadius)
	{
		short ave = 0;
		//		AddToDatalog(1,nMotorEncoder[motorA]/2);
		for (short i=0;i < 33;i++)                                            //Average sound readings over 2/3 of a second
		{
			soundReading = SensorValue[soundSensor];
			//          		AddToDatalog(2,soundReading);
			// DisplayData(soundReading,true);
			ave = ave+soundReading;
			wait10Msec(2);
		}

		ave = ave/33;

		//Decision block for what to do with recorded sound levels
		if (TURNFORSOUND_METHOD==USE_LOUDEST)
		{
			// DisplayData(oldsoundMax,false);
			if(ave > oldsoundMax)                                                 //compare sound sensor values current vs. old.  If higher
			{
				oldsoundMax = ave;                                                  //update value to current
				peakMotorEncoder = nMotorEncoder[motorA];                           //record motor position
			}
		}
		else if (TURNFORSOUND_METHOD==USE_SOFTEST)
		{
			// DisplayData(oldsoundMax,false);
			if(ave < oldsoundMax)                                                 //compare sound sensor values current vs. old.  If higher
			{
				oldsoundMax = ave;                                                  //update value to current
				peakMotorEncoder = nMotorEncoder[motorA];                           //record motor position
			}
		}
		else
		{
			VectorAddition(peakMotorEncoder,magnitude,nMotorEncoder[motorA]/2,ave^2);
			// DisplayData(ave,true);
			// DisplayData(peakMotorEncoder,false);
		}

		//Incremental turn motor control
		motorEncoderTarget = motorEncoderTarget + turnIncrement;
		motor[motorA] = turnSpeed;                                            //turn at turn speed
		while(nMotorEncoder[motorA] < motorEncoderTarget)                     //loop for incremental turn
		{
			wait1Msec(1);
		} // end incremental turn motor control loop

		motor[motorA] = 0;                                                    //Estop
		wait10Msec(30);                                                       //Wait for motor noise to die down
	} // end while loop

	oldsoundMax = 0; // reset old sound
	switch(TURNFORSOUND_METHOD)
	{
		case USE_LOUDEST:
        	motorEncoderTarget = turnRadius - peakMotorEncoder;
        	break;
		case USE_SOFTEST:
        	motorEncoderTarget = turnRadius - peakMotorEncoder + 360;
        	break;
		case USE_VECTORADD:
      	  	motorEncoderTarget = turnRadius - (peakMotorEncoder*2);
        	break;
	}

	//      	SaveNxtDatalog();

	//Turn to selected direction (value in motorEncoderTarget)
	nSyncedMotors = synchNone;                                              //Will occasionally throw "cannot update slave sync" in nMotorEncoder otherwise
	nMotorEncoder[motorA] = 0;
	nMotorEncoder[motorB] = 0;
	nSyncedMotors         = synchBA;                                        //Sync Motors for (CW/CCW?)turn - B master, A slave
	nSyncedTurnRatio      = -100;
	while(nMotorEncoder[motorB] < motorEncoderTarget)
	{
		motor(motorB) = gototurnSpeed;                                        //Turn at gototurnSpeed rate
	}

 	motor(motorB) = 0;                                                      //Estop
 	nSyncedMotors         = synchAB;
	nSyncedTurnRatio      = 100;                                            //Sync for forward motion
 	state = GOTOSOUND;                                                   //turnforsound complete, go to state (GOTOSOUND)
}

task main() {
	wait10Msec(1);
	wait10Msec(20);
	motor[motorA] = goSpeed;
	motor[motorB] = goSpeed;
	wait10Msec(50);
	motor[motorA] = 0;
	motor[motorB] = 0;
	//  nDatalogSize = 2000;
	nSyncedMotors = synchAB;
	nSyncedTurnRatio = 100;
	state = TURNFORSOUND;
	DisplayData(state,true);

	while(1) {

		wait10Msec(20);
		DisplayData(state,true);

		switch (state) {
			case GOTOSOUND:                                             //GOTOSOUND state
				//motor(motorA) = goSpeed;
				wait10Msec(10);                                          //Get going before checking sound
				oldsoundMax = SensorValue[soundSensor];                  //Set old sound max == current sensor lvl

				while (state == GOTOSOUND) {                               //go loop - go forward while current sound > oldsound - soundbuffer
					motor(motorA) = goSpeed;
					//DisplayData(SensorValue[soundSensor],true);
					if (SensorValue[soundSensor] > oldsoundMax) {
						oldsoundMax = SensorValue(soundSensor);
					}

					//DisplayData(oldsoundMax,false);

					// Wall behavior.
					if (SensorValue[touchSensor]==1){
						motor(motorA) = 0;
						GoReverse(4);
						TurnRight(270);
						motor(motorA) = goSpeed;
						wait10Msec(200);
					}

					state = checkBehaviorState(oldsoundMax);
					DisplayData(state,true);
					//DisplayData(SensorValue[lightSensor],false);
				} // end GOTOSOUND while loop

				break;
			case IMTHEPRINCESS:
				imThePrincess();
				break;
			case FOUNDPRINCESS:
				foundPrincess();
				break;
			case TURNFORSOUND:
				soundSeeking();
				break;
		}
	}
}
