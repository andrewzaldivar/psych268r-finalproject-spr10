#pragma config(Sensor, S1,     mic,                 sensorSoundDBA)
#pragma config(Sensor, S2,     touch,               sensorTouch)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// GENERAL INSTRUCTIONS:
// Based on our assigned work, we should only need to do the following
//  - Add your new #define state with a new number for it.
//  - Add fixed parameters (e.g. thresholds, etc.) to the #define section below.
//  - Add any global variable defs.
//  - Add your new task, using something like the name of your state.
//  - Add your new function to provide state transition, E.g. int GetNextState_WAIT_START().
//  - Add any background tasks (e.g. continous sensory processing)
//  - Add your state as a new case to these three generic methods:
//     - GetStateChange
//     - StartState
//     - StopState
//  - Add any initialization code you might need to InitRobotRunOnce().



//////////////////////////////////////////////////////
////// GLOBALS ///////////////////////////////////////
//////////////////////////////////////////////////////


// ADD YOUR STATE CUSTOMIZATION
//
// State enumeration definitions. (Note: no "=" sign or ";")
// Since these are just labels, the order does not matter!
//
// INSTRUCTIONS:
// Do not reorder or change their numbers, just add a new one.
// USE ALL CAPS.
//
#define WAIT_START 1
#define GAME_OVER 2
#define WAIT 3
#define SCREAMBOT 4
#define MAYBE_FOUND 5
#define REALLY_FOUND 6
//#define FOO 3


// ADD YOUR STATE CUSTOMIZATION
//
// Parameters for the robot should all go here.
//
// INSTRUCTIONS:
// In the rest of the code do NOT use hard-coded constants.
// Use a CAPITALIZED_VARIABLE and define it and describe it here.
//
#define WAIT_START_TIME_MS 1000 // time to wait in WAIT_START
#define DISP_UPDATE_PERIOD_MS 10  // how often the display updates
#define INIT_ROBOT_DELAY_MS 500   // delay after program starts

#define SCREAM_LENGTH_TMS 400 // 300 * 10 msecs
#define THRESHOLD 30
#define SCREAM_VOL 4
#define SCREAM_FREQ 1066
#define MIN_CLUSTER_NUM 3
#define MAYBE_TO_REALLY_DETECT_TIME_TMS 300 // * 10msecs
#define INDIV_CALL_DUR_TMS 200
#define MAX_CALL_WAIT_TIME_TMS 500 // * 10msecs


// ADD YOUR STATE CUSTOMIZATION
//
// Global variables
//
// INSTRUCTIONS:
// Add any additional global variables here only.
//
int state = -1;
int cluster_counter = 0;
int local_cluster_counter = 0;





//////////////////////////////////////////////////////
////// STATE TASKS and STATE TRANSITION checks  //////
//////////////////////////////////////////////////////


// STATE
//
// The intial state where the robot is waiting
// for something to start it.  See getChangeState_WAIT_START().
task Wait() {
  while ( true ) {
    wait1Msec( 100 );
  }
}

// TRANSITION
//
// At the moment, if we are in WAIT_START
// then we should always transition to the next state.
int GetNextState_WAIT() {
  if ( SensorValue(touch) ) {
    return SCREAMBOT;
  }
  else if ( SensorValue(mic) > THRESHOLD ) {
    return MAYBE_FOUND;
  }
  else {
    return 0;
  }
}


// STATE
//
task Screambot() {
  while ( true ) {

    // A new round of call and response is being initiated
    // Therefor, zero out the number of neighbors this
    // robot thinks are nearby
    cluster_counter = 0;
    local_cluster_counter = 0;

    // Play a "scream" tone and wait until the tone
    // is finished playing before proceeding.
    ClearTimer(T2);
    PlayImmediateTone( SCREAM_FREQ , SCREAM_LENGTH_TMS );
    while ( time10[T2] < SCREAM_LENGTH_TMS ) {
      wait1Msec( 5 );
    }

    // Wait up to a maximum amount of time for a neighboring
    // robot to respond.  Whenever a loud sound is detected,
    // this robot will wait until that sound is done playing
    // before waiting for the max time to give up counting.
    // This robot counts the number of raises in sound level
    // as the number of nearby neighbors.
    //
    // Start some waiting time and assume that sound level
    // starts "high".  Therefore, first quiet is needed
    // before any detection of neighbors will occur.
    ClearTimer(T2);
    bool bWasLow = false; // current sound level is "high"
    // Wait up to the max time for waiting for a response.
    // The timer is reset (to zero) inside the loop in case
    // new responses are detected.
    while ( time10[T2] < ( 2 * MAX_CALL_WAIT_TIME_TMS ) ) {

      if ( SensorValue(mic) > THRESHOLD ) {
        // If the sound is high, then we must wait until
        // the sound is low again before we start waiting
        // for the (max) time of non-response-detected.
        ClearTimer(T2);
      }

      if ( bWasLow && SensorValue(mic) > THRESHOLD ) {
        // Sound increased.
        // There is some neighbor present, so count it.
        local_cluster_counter++;
        // Keep waiting until sound level drops. (redundant call, but OK).
        ClearTimer(T2);
        // Set current sound level to be "high".
        bWasLow = false; // current sound level is "high"
      }

      if ( !bWasLow && SensorValue(mic) < THRESHOLD ) {
        // Sound decreased
        // Note: No change in timer: we low level mic means we should
        // start waiting for the max timeout.
        // Set current sound level to be "low".
        bWasLow = true; // current sound level is "low"
      }

      wait1Msec( 5 );

    }

    // After tallying the total neighbor count,
    // set the global variable used to switch out
    // of this "scream" state.
    cluster_counter = local_cluster_counter;

    wait1Msec( 10 );

  }
}

// TRANSITION
//
// Switch out of the SCREAMBOT state only when
// the global variable, cluster_counter is above a
// required minimum.
// This also zeros out the counter and the displayed
// counter (local_cluster_counter).
int GetNextState_SCREAMBOT() {
  if ( MIN_CLUSTER_NUM <= cluster_counter ) {
    cluster_counter = 0;
    local_cluster_counter = 0;
    return WAIT;
  }
  else {
    return 0;
  }
}


int maybe_found_next_state = 0;

// STATE
//
task MaybeFound() {

  while ( true ) {

    // Default to staying in this state until
    // we specify otherwise.
    maybe_found_next_state = 0;

    ClearTimer(T2);

    // Only if a loud sound lasts long enough do
    // we transition to the REALLY_FOUND state.
    // Else, go back to WAIT.
    while ( SensorValue(mic) > THRESHOLD ) {
      if ( time10[T2] > MAYBE_TO_REALLY_DETECT_TIME_TMS ) {
        maybe_found_next_state = REALLY_FOUND;
      }
    }

    if ( 0 == maybe_found_next_state ) {
      maybe_found_next_state = WAIT;
    }

    wait1Msec( 10 );

  }
}

// TRANSITION
//
// At the moment, if we are in WAIT_START
// then we should always transition to the next state.
int GetNextState_MAYBE_FOUND() {
  return  maybe_found_next_state;
}

int really_found_next_state = 0;

// STATE
//
task ReallyFound() {

  while ( true ) {

    local_cluster_counter = 0;

    // Default to staying in this state until
    // we specify otherwise.
    really_found_next_state = 0;

    // Wait for screamer to stop screaming
    while ( SensorValue(mic) > THRESHOLD ) {
      wait1Msec( 5 );
    }

    // wait a random amount of time after the screamer
    // stops screaming to respond. unless another robot
    // calls out first, in which case we reset the timer.
    //
    // TODO: Consider putting in a timer to detect that the
    // other robot's interrputing call is _long_ enough
    // to qualify (i.e. is INDIV_CALL_DUR_MS).

    bool bWasLow = true; // assume sound level is low to start.
    ClearTimer(T2);
    // Make sure to wait at least a little time before callback.
    int wait_before_call_time_tms = random[MAX_CALL_WAIT_TIME_TMS - 100] + 100;

    // while not yet reached my time to chime in
    while ( time10[T2] < wait_before_call_time_tms ) {

      // see if another has chimed in or is still chiming in.
      if ( SensorValue(mic) > THRESHOLD ) {
        // Force this robot to wait for any high level to drop.
        // This waits for any length of time of other robots
        // responding to screamer (or screamer still calling out).
        ClearTimer(T2);
      }

      if ( bWasLow && SensorValue(mic) > THRESHOLD ) {
        // Sound increased.
        // Force this robot to wait for any high level to drop before
        // waiting its current wait_before_call_time_tms time.
        ClearTimer(T2);
        local_cluster_counter++;
        bWasLow = false;
      }

      if ( !bWasLow && SensorValue(mic) < THRESHOLD ) {
        // Sound decreased.
        // Once a sound level has dropped, this robot
        // should try a different wait time:
        // so reset my wait_before_call_time
        ClearTimer(T2);
        wait_before_call_time_tms = random[MAX_CALL_WAIT_TIME_TMS];
        bWasLow = true;
      }

      wait1Msec( 5 );

    }

    // The robot has waited up to the MAX_CALL_WAIT_TIME_TMS
    // and no other robots have responded in that time.
    // Therefore, it assumes that it is its own turn to respond.
    ClearTimer(T2);
    PlayImmediateTone( SCREAM_FREQ , INDIV_CALL_DUR_TMS );
    while ( time1[T2] < INDIV_CALL_DUR_TMS) {
      wait1Msec( 5 );
    }

    // After a response, it should go back to waiting to see if
    // there is a screamer nearby.

    really_found_next_state = WAIT;

    wait1Msec( 10 );

    local_cluster_counter = 0;

  }
}

// TRANSITION
//
// At the moment, if we are in WAIT_START
// then we should always transition to the next state.
int GetNextState_REALLY_FOUND() {
  return really_found_next_state;
}














// STATE
//
// The intial state where the robot is waiting
// for something to start it.  See getChangeState_WAIT_START().
task WaitStart() {
  while ( true ) {
    wait1Msec( 100 );
  }
}

// TRANSITION
//
// At the moment, if we are in WAIT_START
// then we should always transition to the next state.
int GetNextState_WAIT_START() {
  if ( time1[T1] > WAIT_START_TIME_MS ) {
    return WAIT;
  }
  else {
    return 0;
  }
}



// STATE
//
// The intial state where the robot is waiting
// for something to start it.  See getChangeState_WAIT_START().
task GameOver() {
  while ( true ) {
    wait1Msec( 100 );
  }
}
// TRANSITION
//
// At the moment, if we are in GAME_OVER
// then we should never transition to another state.
int GetNextState_GAME_OVER() {
  return 0;
}





///////////////////////////////////////////////////////
////// BACKGROUND TASKS, E.G. SENSORY PROCESSING //////
///////////////////////////////////////////////////////


// BACKGROUND TASK
//
// Displays any information that is useful.
task UpdateDisplay() {
  while ( true ) {

    nxtDisplayTextLine( 7 , "State: %d", state );

    if ( bSoundActive ) {
      nxtDisplayTextLine( 6 , "Sound Q: playing" );
    }
    else {
      nxtDisplayTextLine( 6 , "Sound Q: no" );
    }

    nxtDisplayTextLine( 5 , "Mic: %d" , SensorValue(mic) );
    nxtDisplayTextLine( 4 , "Neighbors: %d", local_cluster_counter );

    wait1Msec( DISP_UPDATE_PERIOD_MS ); // wait a bit

  }
}



//////////////////////////////////////////////////
////// ADD CASE STATEMENTS TO THESE METHODS //////
//////////////////////////////////////////////////


// ADD YOUR STATE CUSTOMIZATION
// DO NOT USE (called automatically)
//
// INSTRUCTIONS:
// Make sure you just enter a new case in using the given example.
// It should only set the "response" variable to the state that
// the robot should be set TO based on current conditions of the
// robot.  What those current conditions are is up to the coders.
// Please use the suggested function naming convention for
// checking the conditions of state transition.
//
int GetStateChange( int s ) {

  // this method will return "response" as the state to send
  // the robot to, given that it is in state "s".
  int response = -1; // this should never be returned as -1. It should change below.

  // checks if should switch from state "s" to something else.
  switch ( s ) {
    case WAIT_START:
      response = GetNextState_WAIT_START();
      break;
    case GAME_OVER:
      response = GetNextState_GAME_OVER();
      break;
    case WAIT:
      response = GetNextState_WAIT();
      break;
    case SCREAMBOT:
      response = GetNextState_SCREAMBOT();
      break;
    case MAYBE_FOUND:
      response = GetNextState_MAYBE_FOUND();
      break;
    case REALLY_FOUND:
      response = GetNextState_REALLY_FOUND();
      break;
    //case FOO:
      //response = getNextState_FOO();
      //break;
    // ... (ADD NEW CASES / STATES HERE)
    default:
      break;
  }

  return response;

}


// ADD YOUR STATE CUSTOMIZATION
// DO NOT USE (called automatically)
//
// This is automatically called by the main task's state transitor loop.
//
// INSTRUCTIONS:
//  - Make sure you just enter a new case in using the given example.
//  - Make sure you call StartTask for your state's given task.
//
void StartState( int s ) {
  // Start the appropriate task for state s
  switch ( s ) {
    case WAIT_START:
      StartTask( WaitStart );
      break;
    case GAME_OVER:
      StartTask( GameOver );
      break;
    case WAIT:
      StartTask( Wait );
      break;
    case SCREAMBOT:
      StartTask( Screambot );
      break;
    case MAYBE_FOUND:
      StartTask( MaybeFound );
      break;
    case REALLY_FOUND:
      StartTask( ReallyFound );
      break;
    //case FOO:
      //StartTask( Foo );
      //break;
    // ... (ADD NEW CASES / STATES HERE)
    default:
      break;
  }
}


// ADD YOUR STATE CUSTOMIZATION
// DO NOT USE (called automatically)
//
// This is automatically called by the main task's state transitor loop.
//
// INSTRUCTIONS:
//  - Make sure you just enter a new case in using the given example.
//  - Make sure you call StopTask for your state's given task.
//  - Make sure your task shuts down "cleanly".
//  - Make sure to shut down all the motors your task was using.
//
void StopState( int s ) {
  // Stop the appropriate task for state s
  switch ( s ) {
    case WAIT_START:
      StopTask( WaitStart );
      break;
    case GAME_OVER:
      StopTask( GameOver );
      break;
    case WAIT:
      StopTask( Wait );
      break;
    case SCREAMBOT:
      StopTask( Screambot );
      break;
    case MAYBE_FOUND:
      StopTask( MaybeFound );
      break;
    case REALLY_FOUND:
      StopTask( ReallyFound );
      break;
    //case FOO:
      //motor[motorA] = 0;
      //motor[motorB] = 0;
      //motor[motorC] = 0;
      //StopTask( Foo );
      //break;
    // ... (ADD NEW CASES / STATES HERE)
    default:
      break;
  }
}





///////////////////////////////////////////////
////// ADD INITIALIZATION TO THIS METHOD //////
///////////////////////////////////////////////


// TOUCH MINIMALLY, ONLY IF NECESSARY
// DO NOT USE (called automatically)
//
// This is called only once at the very beginning of the
// robots main task.
//
// "Contracts" wit respect to motor encoder initializations,
// global variable initialization, etc. is established here.
//
// The "*" comments should remain as headers for major
// things this method needs to accomplish before returning
// control to the main task's while loop.
void InitRobotRunOnce() {

  // * Initial wait for 1/2 second to ignore initial readings of the Sensors.
  // Allow operator to move away.
  wait1Msec(INIT_ROBOT_DELAY_MS);

  // * Clear encoders
  nMotorEncoder[motorA] = 0;
  nMotorEncoder[motorB] = 0;
  nMotorEncoder[motorC] = 0;

  // * Setup motors sync (?)
  //
  // TBD

  // * Initialize global variables
  //
  // TBD
  //
  ClearTimer(T1); // timer for waiting to start game
  nVolume = SCREAM_VOL;

  // * Start Background Tasks
  StartTask( UpdateDisplay );

  // * Set the beginning state and start its task
  state = WAIT_START;
  StartState( state );

}





////////////////////////////////////////////
////// DO NOT TOUCH FOLLOWING METHODS //////
////////////////////////////////////////////


// DO NOT TOUCH
// DO NOT USE (called automatically)
//
// Calls initialization code.
// Then runs an infinite loop that checks a generic method
// to determine if and when a state should be switched.
// This task handles the timing of calling the startState and
// stopState methods.
//
// No specialization should be done in this method.  Leave it
// alone.  See the instructions at the top of the file.
task main() {

  // Initialization and setup
  // (remember that "contracts" wrt motor encoders, timers,
  // motors, etc. should be established).
  InitRobotRunOnce();

  // State Transitor
  while ( true ) {

    // Generic method for getting if we should change from the current state
    // and what the next state should be.
    // ( next_state == 0 means do not change state.)
    int next_state = GetStateChange( state );

    // Only if there is a change in state do we stop and start tasks, etc.
    // Assume that next_state == 0 or negative means that we should
    // not change the state.
    if ( next_state ) {
      StopState( state ); // stops the current state
      state = next_state; // updates the current state variable
      StartState( next_state ); // starts the given state
    }

  }

}
