#pragma config(Sensor, S1,     touchSensor,         sensorTouch)
#pragma config(Sensor, S4,     soundSensor,         sensorSoundDB)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//globals
#define soundBuffer   13
#define turnRadius    750
#define turnIncrement 90
#define turnBack      0
#define turnSpeed     20
#define gototurnSpeed 40
#define goSpeed       30

//initiate variables
short oldsoundMax;
short peakMotorEncoder;
short state;
int rescueBotCount = 0;
bool rescueSoundPlayed = false;

//states
#define NEWROUND       0
#define DISPERSAL      1
#define TURNFORSOUND   2
#define GOTOSOUND      3
#define FOUNDPRINCESS  4
#define IMTHEPRINCESS  5
#define BOT_COUNT 5


/*
void VectorAddition(short &oldDegrees, short &oldMagnitude,short newDegrees, short newMagnitude)
{

  short xDecomp = ( (oldMagnitude) * cosDegrees((oldDegrees/2)) ) + ( newMagnitude * cosDegrees(newDegrees/2) );
  short yDecomp = ( (oldMagnitude) * sinDegrees((oldDegrees/2)) ) + ( newMagnitude * sinDegrees(newDegrees/2) );
  oldMagnitude = (xDecomp^2 + yDecomp^2)^.5;
  oldDegrees = radiansToDegrees(acos(xDecomp/oldMagnitude))*2;
  if (xDecomp < 0)
  {
    if (yDecomp < 0) {oldDegrees = oldDegrees + 360;}     //quadrant 3
    else {oldDegrees = oldDegrees + 180;}                 //quadrant 2
  }
  else
  {
    if (yDecomp < 0) {oldDegrees = oldDegrees + 540;}     //quadrant 4
  }
}
*/

void DisplayData(short data, bool firstDisplay)
{
  if(firstDisplay)
  {
    nxtDisplayCenteredTextLine(0, "Sound Reading");
    nxtDisplayCenteredBigTextLine(1, "%d", data);
  }
  else
  {
    nxtDisplayCenteredTextLine(4, "Max Sound Reading");
    nxtDisplayCenteredBigTextLine(5, "%d", data);
  }
}

void TurnRight(short degree) //Function to rotate the robot "degree" degrees to the right
{
  nSyncedTurnRatio = -100; //Makes the wheels turn in opposite directions
  nMotorEncoder[motorA] = 0; // Initialize wheel counter
  while(nMotorEncoder[motorA] < degree)
  {
    motor[motorA] = 25; //Establish turn power
  }
  motor[motorA] = 0;
  nSyncedTurnRatio = 100;
  wait1Msec(100); //Pause to reduce jerking between operations
}

void GoReverse(short distance)  //input is the distance we wish to go in inches
{
  nMotorEncoder[motorA] = 0;
  nSyncedTurnRatio = 100;

  //1 rotation is approximately 7.25 inches
  while(nMotorEncoder[motorA] > -1*distance*(360/7.25))  //Calculates distance in inches
  {                                                   //as a function of wheel rotations
    motor[motorA] = -30;  //Reverse Motor speed
  }
  motor[motorA] = 0;
  wait1Msec(100);
}

int getAvgSoundForInterval (int interval)
{
  int soundValue = 0;
  int count = 0;
  ClearTimer(T1);
  while (time1[T1] < 500)
  {
    soundValue = soundValue + SensorValue[soundSensor];
    count ++;
  }
  int avgSound = soundValue/count;
  return avgSound;
}

int getMaxSoundForInterval (int interval)
{
  int soundValue = 0;
  int checkValue = 0;
  ClearTimer(T1);
  while (time1[T1] < 500)
  {
    checkValue = SensorValue[soundSensor];
    if (soundValue < checkValue)
    {
      soundValue = checkValue;
    }
  }
  return soundValue;
}

bool fBeepDetection ()
{
  bool beepDetection = false;
  ClearTimer (T2);
  int initialSound = SensorValue[soundSensor];
  while (time1[T2] < 600)
  {
    int diff = abs (SensorValue[soundSensor] - initialSound);
    if (diff > 40)
    {
      beepDetection = true;
      break;
    }
  }
  return beepDetection;
}

task playRescueTone ()
{
  while (rescueSoundPlayed == false)
  {
    if (SensorValue[soundSensor] < 80)
    {
      PlayTone(1184, 500);
      rescueSoundPlayed = true;
      break;
    }
  }
}

task main ()
{
  state = NEWROUND;
  while(1)
  {
    DisplayData(state,false);
    if (state==NEWROUND)      {state = TURNFORSOUND;}

    switch (state)
    {
    case NEWROUND:

      //bluetooth stuff
      //vote for princess
      //

      break;


    case DISPERSAL:
      //while(1)
      //{
      //Do dispersal stuff

      //if(bluetooth says there's a sound | I hear a sound)
      //{
      //  state = TURNFORSOUND
      //}
      //}

      GoReverse(20);
      TurnRight (180);
      motor(motorA) = goSpeed;
      state = TURNFORSOUND;
      wait10Msec(2000);
      break;


    case TURNFORSOUND:

      nSyncedMotors = synchNone;                                              //Will occasionally throw "cannot update slave sync" in nMotorEncoder otherwise
      nMotorEncoder[motorA] = 0;                                              //reset nMotorEncoder motorA
      nMotorEncoder[motorB] = 0;                                              //reset nMotorEncoder motorB - redundant
      nSyncedMotors         = synchAB;                                        //Sync Motors for (CW/CCW?)turn - A master, B slave
      nSyncedTurnRatio      = -100;                                           //Sync for in place turning
      oldsoundMax           = 0;                                              //reset oldsoundMax
      peakMotorEncoder    = 0;                                                //reset turn1peakdBmotorValue
      wait10Msec(30);
      short motorEncoderTarget = 0;
      //short magnitude = SensorValue[soundSensor];
      while((nMotorEncoder[motorA] < turnRadius))         //loop for Turn direction 1 and sample
      {
        motorEncoderTarget = motorEncoderTarget + turnIncrement;
        motor[motorA] = turnSpeed;                                            //turn at turn speed
        while(nMotorEncoder[motorA] < motorEncoderTarget)                     //loop for incremental turn
        {
          wait1Msec(1);
        }
        motor[motorA] = 0;                                                    //Estop
        wait10Msec(30);
        DisplayData(SensorValue[soundSensor],true);
        DisplayData(oldsoundMax,false);

        //VectorAddition(peakMotorEncoder,magnitude,nMotorEncoder[motorA],SensorValue[soundSensor]);

        if(SensorValue[soundSensor] > oldsoundMax)                            //compare sound sensor values current vs. old.  If higher
        {
          oldsoundMax = SensorValue[soundSensor];                             //update value to current
          peakMotorEncoder = nMotorEncoder[motorA];                         //record motor position
        }
      }
      oldsoundMax           = 0;                                              //reset oldsoundMax
      motorEncoderTarget = turnRadius - turnIncrement - peakMotorEncoder;

      state = GOTOSOUND;                                                      //turnforsound complete, go to state (GOTOSOUND)
      break;


    case GOTOSOUND:                                                           //GOTOSOUND state

      oldsoundMax = SensorValue[soundSensor];                                 //Set old sound max == current sensor lvl
      nSyncedMotors = synchNone;                                              //Will occasionally throw "cannot update slave sync" in nMotorEncoder otherwise
      nMotorEncoder[motorA] = 0;
      nMotorEncoder[motorB] = 0;
      nSyncedMotors         = synchBA;                                        //Sync Motors for (CW/CCW?)turn - B master, A slave
      nSyncedTurnRatio      = -100;
      while(nMotorEncoder[motorB] < motorEncoderTarget)
      {
        motor(motorB) = gototurnSpeed;                                        //Turn at gototurnSpeed rate
      }
      motor(motorB) = 0;                                                      //Estop

      nSyncedMotors         = synchAB;
      nSyncedTurnRatio      = 100;                                            //Sync for forward motion
      motor(motorA) = goSpeed;
      wait10Msec(5);
      while (state==GOTOSOUND) //go loop - go forward while current sound > oldsound - soundbuffer
      {

        motor(motorA) = goSpeed;
        DisplayData(SensorValue[soundSensor],true);
        if (SensorValue[soundSensor] > oldsoundMax) { oldsoundMax = SensorValue(soundSensor); }
        DisplayData(oldsoundMax,false);

        if (SensorValue[soundSensor] > 93)
        {
          state = FOUNDPRINCESS;                                        //Go to state (FOUNDPRINCESS)
        }
        else if (SensorValue[touchSensor]==1)
        {
          motor(motorA) = 0;
          GoReverse(4);
          TurnRight(270);
          motor(motorA) = goSpeed;
          wait10Msec(200);
        }
        else if(SensorValue[soundSensor] < oldsoundMax - soundBuffer)
        {
          state = TURNFORSOUND;
        }
      }
      break;


    case FOUNDPRINCESS:                                                  //FOUNDPRINCESS state

      // code for FOUNDPRINCESS here
      // stop, wiggle, squeel, whatever...
      // state = NEWROUND; // end of FOUNDPRINCESS code, return bots to NEWROUND state
      StartTask (playRescueTone);
      while(1)
      {
        if (fBeepDetection ())
        {
          motor(motorA) = 0;
          nVolume = 4;
          PlayTone(1184,100);
        }
        else
        {
          state = DISPERSAL;
          break;
        }
      }
      break;


    case IMTHEPRINCESS:

      //Do Princess like stuff
      while (1)
      {
        if (rescueBotCount < BOT_COUNT)
        {
          PlayTone(1184, 500);
          wait1Msec (10);
          int rescueSoundValue = getAvgSoundForInterval(500);
          if (rescueSoundValue > 90)
          {
            rescueBotCount++;
          }
          wait1Msec (10);
        }
        else
        {
          state = DISPERSAL;
          break;
        }
      }
      break;
    }                                                                           //end switch
  }                                                                           //end main while(1) loop
}                                                                             //end task main
